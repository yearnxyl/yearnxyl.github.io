<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2023/05/14/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a class="link"   href="https://hexo.io/" >Hexo<i class="fas fa-external-link-alt"></i></a>! This is your very first post. Check <a class="link"   href="https://hexo.io/docs/" >documentation<i class="fas fa-external-link-alt"></i></a> for more info. If you get any problems when using Hexo, you can find the answer in <a class="link"   href="https://hexo.io/docs/troubleshooting.html" >troubleshooting<i class="fas fa-external-link-alt"></i></a> or you can ask me on <a class="link"   href="https://github.com/hexojs/hexo/issues" >GitHub<i class="fas fa-external-link-alt"></i></a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a class="link"   href="https://hexo.io/docs/writing.html" >Writing<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a class="link"   href="https://hexo.io/docs/server.html" >Server<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a class="link"   href="https://hexo.io/docs/generating.html" >Generating<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a class="link"   href="https://hexo.io/docs/one-command-deployment.html" >Deployment<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
  </entry>
  <entry>
    <title>Java反射</title>
    <url>/2023/06/08/Java%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<p>反射：将类的各个组成部分封装为其他对象。</p>
<p>Java代码在计算机中经历了三个阶段：源阶段-&gt;Class对象阶段-&gt;Runtime运行时阶段。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://yearnxyl.oss-cn-beijing.aliyuncs.com/img/1659361692184-df5e15a2-0ff1-47d0-9767-d95ef24a9903.png"
                      alt="image.png"
                ></p>
<p>源代码阶段：在编辑器中写的便是源代码。以.java做后缀。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://yearnxyl.oss-cn-beijing.aliyuncs.com/img/1658958834552-6f17393d-7d2a-4ef5-bdb4-eb180dd3c51c.png"
                      alt="image.png"
                ></p>
<p>使用javac命令可以将.java文件编译为字节码文件，以.class结尾。此时认为仍处于源代码阶段。如下为class文件，具体含义暂不做分析。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://yearnxyl.oss-cn-beijing.aliyuncs.com/img/1659050135411-8ee0b254-39b0-4a46-87db-932e25cb1f06.png"
                      alt="image.png"
                ></p>
<p>Class类对象阶段：使用javac编译成的字节码文件经过jvm中ClassLoader的加载，在内存中生成Class类对象。Class类对象由成员变量Field、构造方法Constructor、成员方法Method组成。以上面Person对象为例，经过ClassLoader加载，name和age两个成员变量封装为Field[]对象，Person()方法封装为Constructor[]对象，eat()封装为Methods[]对象。而这个封装的过程便是反射机制。</p>
<p>Runtime阶段：实例化类对象，在内存中生成实例化对象。</p>
<h3 id="获取Class类对象的四种方法"><a href="#获取Class类对象的四种方法" class="headerlink" title="获取Class类对象的四种方法"></a>获取Class类对象的四种方法</h3><p><code>反射的作用：获取Class类对象。</code></p>
<p>针对Java代码在计算机的不同阶段，存在不同的方法来获取Class类对象。</p>
<ol>
<li>源代码阶段：Class.forName(“全类名”)：将字节码文件加载进内存，返回Class类对象。</li>
<li>Class类对象阶段：类名.class：通过类名的属性class获取。</li>
<li>实例化对象阶段：对象.getClass：getClass()方法在Object类中定义着。</li>
<li>类加载器ClassLoader.getSystemClassLoader().loadClass(“全类名”)</li>
</ol>
<p>编写Person类</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://yearnxyl.oss-cn-beijing.aliyuncs.com/img/1659366695287-caf09e61-9e59-4862-9839-c7f7880932bb.png"
                      alt="image.png"
                ></p>
<p>获取Class类对象</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://yearnxyl.oss-cn-beijing.aliyuncs.com/img/1660095967523-d8071b26-459f-4023-847d-0e21f5f1dc45.png"
                      alt="1660095958223.png"
                ></p>
<p>同一个字节码文件(*.class)，在一次程序运行过程中，只会被加载一次。因此获取的四个Class类对象是一样的。</p>
<p>这里有一个容易混淆的地方，我们介绍了四种方法来获取Class类对象，观察其输出结果，均为<code>org.domain.Person</code>。但是java内置的Class类对象应该是<code>java.lang.Class</code>，两者有什么区别？</p>
<p><code>java.lang.Class</code>不只是类对象，还是一个模板，<code>org.domain.Person</code>便是根据该模板生成的，因此<code>org.domain.Person</code>本质上也是<code>java.lang.Class</code>类对象。<code>org.domain.Person</code>下存在一个<code>getClass()</code>方法来获取<code>java.lang.Class</code>对象。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://yearnxyl.oss-cn-beijing.aliyuncs.com/img/1661613633642-c7d1c555-e496-4d4a-9126-b77e544d9214.png"
                      alt="image.png"
                ></p>
<h3 id="获取Class类成员变量"><a href="#获取Class类成员变量" class="headerlink" title="获取Class类成员变量"></a>获取Class类成员变量</h3><p>获取Class类成员变量主要是为了对其数值进行更改。</p>
<ol>
<li><code>Field[] getFields()</code>、<code>Field getField(String name)</code>获取public修饰的成员变量</li>
<li><code>Field[] getDeclaredFields()</code>、<code>Field getDeclaredField(String name)</code>获取全部成员变量</li>
<li><code>void set(Object obj,Object value)</code>设置field值</li>
<li><code>Object get(Object obj)</code>获取值</li>
<li>针对非public修饰符的成员变量，在单独反射时，需要将其<code>setAccessible(true)</code>;</li>
</ol>
<p>实例：</p>
<p>首先编写Person类如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> String a;</span><br><span class="line">    <span class="keyword">protected</span> String b;</span><br><span class="line">    String c;</span><br><span class="line">    <span class="keyword">private</span> String d;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name,String a)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">        <span class="built_in">this</span>.a=a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">( String name,<span class="type">int</span> age)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">        <span class="built_in">this</span>.age=age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String a,String... name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.a=a;</span><br><span class="line">        <span class="keyword">for</span>(String n:name)&#123;</span><br><span class="line">            System.out.println(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, a=&#x27;&quot;</span> + a + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, b=&#x27;&quot;</span> + b + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, c=&#x27;&quot;</span> + c + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, d=&#x27;&quot;</span> + d + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;eat...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">(String food)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;eat...&quot;</span>+food);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用反射机制获取Class类成员变量并修改：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.ReflectDemo;</span><br><span class="line"><span class="keyword">import</span> org.domain.Person;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span>Person.class;</span><br><span class="line">        <span class="comment">//Field[] getFields()</span></span><br><span class="line">        Field[] fields=cls.getFields();</span><br><span class="line">        <span class="keyword">for</span>(Field field:fields)&#123;</span><br><span class="line">            System.out.println(field);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;----------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Field a=cls.getField(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        System.out.println(a);</span><br><span class="line">        <span class="comment">//获取a的值。get(Object obj)</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        Object value=a.get(p);</span><br><span class="line">        System.out.println(value);</span><br><span class="line">        <span class="comment">//设置a的值。set(Object obj,Object value)</span></span><br><span class="line">        a.set(p,<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        System.out.println(p);</span><br><span class="line">        System.out.println(<span class="string">&quot;================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取全部成员变量。Field[] getDeclaredFields()</span></span><br><span class="line">        Field[] fields1= cls.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span>(Field field:fields1)&#123;</span><br><span class="line">            System.out.println(field);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取指定私有成员变量。Field getDeclaredField()</span></span><br><span class="line">        Field d=cls.getDeclaredField(<span class="string">&quot;d&quot;</span>);</span><br><span class="line">        <span class="comment">//忽略访问权限修饰符的安全检查</span></span><br><span class="line">        <span class="comment">//暴力反射</span></span><br><span class="line">        d.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        Object value2=d.get(p);</span><br><span class="line">        System.out.println(value2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img  
                     lazyload
                     alt="image"
                     data-src="https://yearnxyl.oss-cn-beijing.aliyuncs.com/img/1660098101087-515a945a-b1fe-42da-93c2-11ab37728342.png"
                      alt="image.png"
                ></p>
<h3 id="获取Class类构造方法"><a href="#获取Class类构造方法" class="headerlink" title="获取Class类构造方法"></a>获取Class类构造方法</h3><p>获取构造方法后，可以使用构造方法创建实例化对象</p>
<ol>
<li><code>Constructor&lt;?&gt;[] getConstructors()</code>、<code>Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes)</code>获取public构造方法</li>
<li><code>Constructor&lt;?&gt;[] getDeclaredConstructors()</code>、<code>Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes)</code>获取全部构造方法</li>
<li><code>constructor.newInstance()</code> 使用构造方法创建实例化对象。</li>
<li>当使用无参数构造方法创建实例化对象时，可以简化为使用Class类对象操作：<code>class.newInstace()</code>。</li>
<li><code>setAccessible()</code>方法适用</li>
</ol>
<p>实例：Person类保持不变</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.ReflectDemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.domain.Person;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectDemo3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Class cls=Person.class;</span><br><span class="line">        <span class="comment">//Constructor&lt;?&gt;[] getConstructors()</span></span><br><span class="line">        Constructor[] constructors=cls.getConstructors();</span><br><span class="line">        <span class="keyword">for</span> (Constructor constructor:constructors)&#123;</span><br><span class="line">            System.out.println(constructors);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Constructor&lt;?&gt; getConstructor(Class&lt;?&gt;... parameterTypes )</span></span><br><span class="line">        Constructor&lt;?&gt; constructor=cls.getConstructor(String.class,<span class="type">int</span>.class);</span><br><span class="line">        System.out.println(constructor);</span><br><span class="line">        <span class="comment">//创建对象</span></span><br><span class="line">        Object person=constructor.newInstance(<span class="string">&quot;张三&quot;</span>,<span class="number">23</span>);</span><br><span class="line">        System.out.println(person);</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------&quot;</span>);</span><br><span class="line">        Constructor&lt;?&gt; constructor1=cls.getConstructor();</span><br><span class="line">        System.out.println(constructor1);</span><br><span class="line">        Object person1=constructor1.newInstance();</span><br><span class="line">        System.out.println(person1);</span><br><span class="line">        <span class="comment">//简化</span></span><br><span class="line">        Object person2=cls.newInstance();</span><br><span class="line">        System.out.println(person2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img  
                     lazyload
                     alt="image"
                     data-src="https://yearnxyl.oss-cn-beijing.aliyuncs.com/img/image-20230609000050942.png"
                      alt="image-20230609000050942"
                ></p>
<h3 id="获取Class类成员方法"><a href="#获取Class类成员方法" class="headerlink" title="获取Class类成员方法"></a>获取Class类成员方法</h3><ol>
<li><code>Method[] getMethods()</code>、<code>Method getMethod(String name,Class&lt;?&gt;... parameterTypes)</code>获取public类成员方法。注意这里获取全部public类成员方法的时候会获取Object类的public成员方法</li>
<li><code>Method[] getDeclaredMethods()</code>、<code>Method getDeclaredMethod(String name,Class&lt;?&gt;... parameterTypes)</code>获取全部类成员方法，当然也包括Object类</li>
<li><code>String method.getName()</code> 获取方法名</li>
<li><code>String class.getName()</code>获取类名</li>
<li><code>method.invoke(Object obj,Class&lt;?&gt;...parameterTypes)</code>执行类成员方法</li>
<li><code>setAccessible()</code>方法适用</li>
</ol>
<p>实例：Person类保持不变</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.ReflectDemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.security.jgss.GSSUtil;</span><br><span class="line"><span class="keyword">import</span> org.domain.Person;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectDemo4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span><span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        Class cls=Class.forName(<span class="string">&quot;org.domain.Person&quot;</span>);</span><br><span class="line">        <span class="comment">//获取指定名称的方法</span></span><br><span class="line">        Method eat_method=cls.getMethod(<span class="string">&quot;eat&quot;</span>);</span><br><span class="line">        System.out.println(eat_method);</span><br><span class="line">        <span class="comment">//输出方法名</span></span><br><span class="line">        String eat_methodName=eat_method.getName();</span><br><span class="line">        System.out.println(eat_methodName);</span><br><span class="line">        <span class="comment">//执行方法</span></span><br><span class="line">        Person person=<span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        eat_method.invoke(person);</span><br><span class="line">        Method eat_method2=cls.getMethod(<span class="string">&quot;eat&quot;</span>,String.class);</span><br><span class="line">        System.out.println(eat_method2);</span><br><span class="line">        eat_method2.invoke(person,<span class="string">&quot;meet&quot;</span>);</span><br><span class="line">        <span class="comment">//获取全部指定类成员方法</span></span><br><span class="line">        Method[] methods=cls.getMethods();</span><br><span class="line">        <span class="keyword">for</span>(Method method:methods)&#123;</span><br><span class="line">            System.out.println(method);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String className=cls.getName();</span><br><span class="line">        System.out.println(className);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img  
                     lazyload
                     alt="image"
                     data-src="https://yearnxyl.oss-cn-beijing.aliyuncs.com/img/1660146493707-73a30df7-753b-45e5-81f6-f584a30e63a8.png"
                      alt="image.png"
                ></p>
<h3 id="Java反射与安全"><a href="#Java反射与安全" class="headerlink" title="Java反射与安全"></a>Java反射与安全</h3><p>P牛：Java反射可以给Java这门静态语言赋予动态特性。“⼀段代码，改变其中的变量，将会导致这段代码产⽣功能性的变化，我称之为动态特性 ”。</p>
<p>如下代码中<code>execute</code>方法，根据传入的<code>ClassName</code>参数不同，获取不同的<code>Class</code>类对象。再根据<code>MethodName</code>不同，获取该类对象下的方法。最后使用<code>invoke</code>方法来执行该方法。</p>
<p>当不知道传入的参数是什么的时候，这段代码最终实现的功能是未知的。这便是动态特性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.ReflectDemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectDemo5</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(String ClassName,String MethodName)</span><span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        Class cls=Class.forName(ClassName);</span><br><span class="line">        cls.getMethod(MethodName).invoke(cls.newInstance());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        String ClassName=sc.next();</span><br><span class="line">        String MethodName=sc.next();</span><br><span class="line">        ReflectDemo5 ref=<span class="keyword">new</span> <span class="title class_">ReflectDemo5</span>();</span><br><span class="line">        ref.execute(ClassName,MethodName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有一个容易忽略的点，<code>forName</code>是<code>java.lang.Class</code>类的static方法，只要我们能拿到<code>java.lang.Class</code>类便可以执行<code>forName</code>，而在“获取Class类对象的四种方法”小节的最后，我们发现任何Class类都可以通过<code>getClass()</code>方法来获取<code>java.lang.Class</code>对象。</p>
<p>例如存在<code>String a</code>：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://yearnxyl.oss-cn-beijing.aliyuncs.com/img/1661614173345-b1686b43-85d2-4908-9747-f0224cc7fde8.png"
                      alt="image.png"
                ></p>
<p>当然在本例中的cls3，通过<code>java.lang.Class</code>对象最后又获取到<code>java.lang.Class</code>对象是没什么意义的，这里仅仅是要了解其方法。</p>
<p><code>forName</code>有三个函数重载</p>
<ul>
<li>forName(String className)</li>
<li>forName(String name, boolean initialize,ClassLoader loader)</li>
<li>forName(Module module, String name) &#x2F;&#x2F;模块部分是JDK9添加的特性，还未学习，暂不考虑学习此方法</li>
</ul>
<p>第一个是常见的获取Class的方式。查看器源代码会发现其最后会返回<code>forName0(className, true, ClassLoader.getClassLoader(caller), caller)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String className)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">    <span class="keyword">return</span> forName0(className, <span class="literal">true</span>, ClassLoader.getClassLoader(caller), caller);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>至于第二个方法，忽略中间代码，发现其最后返回<code>forName0(name, initialize, loader, caller)</code>，由此可知，方法一是对方法二的一个封装。默认了<code>initialize</code>和<code>loader</code>两个参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String name, <span class="type">boolean</span> initialize,</span><br><span class="line">                               ClassLoader loader)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">    Class&lt;?&gt; caller = <span class="literal">null</span>;</span><br><span class="line">    <span class="type">SecurityManager</span> <span class="variable">sm</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (sm != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// Reflective call to get caller class is only needed if a security manager</span></span><br><span class="line">    <span class="comment">// is present.  Avoid the overhead of making this call otherwise.</span></span><br><span class="line">    caller = Reflection.getCallerClass();</span><br><span class="line">    <span class="keyword">if</span> (loader == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">ccl</span> <span class="operator">=</span> ClassLoader.getClassLoader(caller);</span><br><span class="line">    <span class="keyword">if</span> (ccl != <span class="literal">null</span>) &#123;</span><br><span class="line">    sm.checkPermission(</span><br><span class="line">    SecurityConstants.GET_CLASSLOADER_PERMISSION);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> forName0(name, initialize, loader, caller);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>至于两个参数的含义<code>initialize</code>表示是否进行初始化，<code>loader</code>表示<code>ClassLoader</code>，暂不考虑<code>ClassLoader</code>的学习。</p>
<p>当<code>initialize=true</code>的时候，使用forName来获取Class对象时，Class对象会自动初始化。</p>
<p>在Java中，存在三种初始化方法。分别是<code>static&#123;&#125;</code>，<code>&#123;&#125;</code>和构造函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.ReflectDemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectDemo7</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;static&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;&#123;&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ReflectDemo7() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Reflect&quot;</span>);    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ReflectDemo7 rf=<span class="keyword">new</span> <span class="title class_">ReflectDemo7</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么三者存在什么区别？</p>
<blockquote>
<p>Person p &#x3D; new Person(“zhangsan”,20); 该句话都做了什么事情？</p>
<p>1，因为new用到了Person.class.所以会先找到Person.class文件并加载到内存中。</p>
<p>2，执行该类中的static代码块，如果有的话，给Person.class类进行初始化。</p>
<p>3，在堆内存中开辟空间，分配内存地址。</p>
<p>4，在堆内存中建立对象的特有属性。并进行默认初始化。</p>
<p>5，对属性进行显示初始化。</p>
<p>6，对对象进行构造代码块初始化。</p>
<p>7，对对象进行对应的构造函数初始化。</p>
<p>8，将内存地址付给栈内存中的p变量。</p>
</blockquote>
<p>从上述可以看出在步骤2就已经运行<code>static&#123;&#125;</code>方法，步骤四运行<code>&#123;&#125;</code>方法，步骤六运行构造代码块。可以运行上面的代码判断顺序是否正确。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://yearnxyl.oss-cn-beijing.aliyuncs.com/img/1662132897467-d153c776-9c17-41f9-a20e-4c866d7ca600.png"
                      alt="image.png"
                ></p>
<p>对比2、4、6三个步骤会发现，<code>static&#123;&#125;</code>方法是对Class类初始化，发生在找到Class类对象的时候。另外两种方法则发生在步骤3分配内存之后。</p>
<p>而我们上面提到的：使用forName来获取Class对象时，Class对象会自动初始化。forName同样存在一个寻找Class类对象的过程，找到对象后执行static方法。但其没有分配内存，也就是后面两种方法并不会执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.ReflectDemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectDemo7</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;static&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;&#123;&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ReflectDemo7() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Reflect&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Class cls=Class.forName(<span class="string">&quot;org.ReflectDemo.ReflectDemo7&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img  
                     lazyload
                     alt="image"
                     data-src="https://yearnxyl.oss-cn-beijing.aliyuncs.com/img/1662133910438-148af0b8-4825-491b-ad36-8390a0aa1422.png"
                      alt="image.png"
                ></p>
<p>当我们能够操作如下代码中的<code>className</code>参数时：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ref</span><span class="params">(String className)</span><span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        Class cls=Class.forName(className);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以将<code>className</code>指向我们构造的恶意类。其中的<code>static&#123;&#125;</code>方法为构造的恶意方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Runtime</span> <span class="variable">rt</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line">            <span class="type">String</span> <span class="variable">command</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;calc&quot;</span>);</span><br><span class="line">            <span class="type">Process</span> <span class="variable">pr</span> <span class="operator">=</span> rt.exec(command);</span><br><span class="line">            pr.waitFor();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>除了使用<code>forName()</code>方法指向恶意类外，也可以使用<code>forName()</code>指向Java的内置类，通过这种方法可以省去<code>import</code>。获取Java内置类之后，若存在无参数构造方法，只要使用<code>class.newInstance()</code>，便可将其实例化（上面获取Class类构造方法提到过），而后利用其属性或方法。例如当我们获取到<code>Runtime</code>实例时，可以使用<code>exec()</code>方法来执行任意命令。</p>
<p>但是很不幸的是，很多时候<code>class.newInstance()</code>会失效。主要原因：</p>
<ul>
<li>类不存在无参数构造方法</li>
<li>类无参数构造方法是私有的</li>
</ul>
<p>例如<code>Runtime</code>类的无参数构造方法便是<code>private</code>，当需要获取<code>Runtime</code>实例化对象时，需要调用其静态方法<code>getRuntime</code>来返回实例化对象。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://yearnxyl.oss-cn-beijing.aliyuncs.com/img/1662455146683-c2881f52-b8d6-41e1-a754-6985e0f355c3.png"
                      alt="image.png"
                ></p>
<p>这么做的目的涉及到Java的单例模式。</p>
<blockquote>
<p>单例模式，属于创建类型的一种常用的软件设计模式。通过单例模式的方法创建的类在当前进程中只有一个实例（根据需要，也有可能一个线程中属于单例，如：仅线程上下文内使用同一个实例）</p>
</blockquote>
<p>如下代码，通过两次new产生的实例化对象是不同的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.ReflectDemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectDemo8</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ReflectDemo8</span><span class="params">()</span>&#123;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String agrs[])</span>&#123;</span><br><span class="line">        ReflectDemo9 rf1=<span class="keyword">new</span> <span class="title class_">ReflectDemo9</span>();</span><br><span class="line">        ReflectDemo9 rf2=<span class="keyword">new</span> <span class="title class_">ReflectDemo9</span>();</span><br><span class="line">        System.out.println(rf1==rf2);<span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是经过单例模式实例化的对象rf1和rf2是相同的。保证了线程中只存在一个<code>ReflectDemo8</code>实例化对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.ReflectDemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectDemo8</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ReflectDemo8 reflect=<span class="keyword">new</span> <span class="title class_">ReflectDemo8</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ReflectDemo8 <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> reflect;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">ReflectDemo8</span><span class="params">()</span>&#123;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String agrs[])</span>&#123;</span><br><span class="line">        ReflectDemo8 rf1=ReflectDemo8.getInstance();</span><br><span class="line">        ReflectDemo8 rf2=ReflectDemo8.getInstance();</span><br><span class="line">        System.out.println(rf1==rf2); <span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回到正题，既然在<code>Runtime</code>类中，<code>getRuntime</code>可以获取实例化对象。那我们直接调用不就好了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.ReflectDemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectDemo9</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>);</span><br><span class="line">        clazz.getMethod(<span class="string">&quot;exec&quot;</span>,String.class).invoke(clazz.getMethod(<span class="string">&quot;getRuntime&quot;</span>).invoke(clazz),<span class="string">&quot;calc.exe&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这么看有点麻烦。拆开来看。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.ReflectDemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectDemo9</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>);</span><br><span class="line">        Object rt=clazz.getMethod(<span class="string">&quot;getRuntime&quot;</span>).invoke(clazz);</span><br><span class="line">        clazz.getMethod(<span class="string">&quot;exec&quot;</span>,String.class).invoke(rt,<span class="string">&quot;calc.exe&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>forName</code>获取<code>getRuntime</code>方法并调用，获取<code>Runtime</code>实例化对象。再获取<code>exec</code>方法并调用，来达到执行命令的目的。刚看到这里的时候有些疑惑。为什么在调用<code>getRuntime</code>方法时<code>invoke(clazz)</code>但是<code>exec</code>方法需要<code>invoke(rt)</code>，一个参数是<code>Class</code>一个参数是<code>Object</code>。查看了一下<code>invoke</code>方法，发现其参数确实是Object。也没有其他的重载。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://yearnxyl.oss-cn-beijing.aliyuncs.com/img/1662608455979-bbd05d33-fed6-4144-9267-51728e80f3a5.png"
                      alt="image.png"
                ></p>
<p>后面查看<code>getRuntime</code>方法和<code>exec</code>方法，发现<code>getRuntime</code>方法是static。查阅资料并尝试后发现确实如此。<a class="link"   href="https://www.baeldung.com/java-invoke-static-method-reflection" >java-invoke-static-method<i class="fas fa-external-link-alt"></i></a></p>
<p>除了使用<code>getRuntime</code>方法外。在获取Class类构造方法章节，我们提到过获取<code>private</code>构造方法的方式：<code>getDeclaredConstructors()</code>。恰巧在<code>Runtime</code>类中存在<code>private</code>构造方法。因此利用暴力反射同样可以获取<code>Runtime</code>实例化对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.ReflectDemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectDemo9</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>);</span><br><span class="line">        Constructor constructor= clazz.getDeclaredConstructor();</span><br><span class="line">        constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        Runtime rt= (Runtime) constructor.newInstance();</span><br><span class="line">        clazz.getMethod(<span class="string">&quot;exec&quot;</span>,String.class).invoke(rt,<span class="string">&quot;calc&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决了无参数构造方法私有后，再来解决不存在无参数构造方法的问题。</p>
<p>普通的有参数构造方法在上面的获取Class类构造方法中提到过了。比较难理解的是当参数为数组时该怎么处理。</p>
<p>以常用到的，可以任意命令执行的另一个类：<code>ProcessBuilder</code>为例。其具有两个重载的构造方法。</p>
<ul>
<li>ProcessBuilder(List command)</li>
<li>ProcessBuilder(String… command)</li>
</ul>
<p>第一个好理解，只要传入的参数为List即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.ReflectDemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectDemo10</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        Class clazz=Class.forName(<span class="string">&quot;java.lang.ProcessBuilder&quot;</span>);</span><br><span class="line">        ((ProcessBuilder)clazz.getConstructor(List.class).newInstance(Arrays.asList(<span class="string">&quot;calc.exe&quot;</span>))).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重点在于第二个。其参数为可变长参数，对于可变长参数，java在编译时会编译成数组。也就是说在java中，以下两种方法是等价的，不可重载的</p>
<ul>
<li>ProcessBuilder(String… command)</li>
<li>ProcessBuilder(String[] command)</li>
</ul>
<p>查看<code>newInstance</code>方法，我们可以看到其参数为数组。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://yearnxyl.oss-cn-beijing.aliyuncs.com/img/1662739375623-5a669727-2a5d-4443-8f28-b2b18c46671e.png"
                      alt="image.png"
                ></p>
<p>而<code>ProcessBuilder</code>的第二个构造函数参数同样也是数组。两者结合，便成为了二维数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.ReflectDemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectDemo10</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        Class clazz=Class.forName(<span class="string">&quot;java.lang.ProcessBuilder&quot;</span>);</span><br><span class="line">        ((ProcessBuilder)clazz.getConstructor(String[].class).newInstance(<span class="keyword">new</span> <span class="title class_">String</span>[][]&#123;&#123;<span class="string">&quot;calc.exe&quot;</span>&#125;&#125;)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至于这里为什么是二维数组。我们可以这么去理解<code>Constructor</code>和<code>newInstance</code>之间的过程</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://yearnxyl.oss-cn-beijing.aliyuncs.com/img/1662996613324-95c9eac1-2137-46cb-8bdb-7b8d39adfb61.png"
                      alt="image.png"
                ></p>
]]></content>
      <categories>
        <category>Java安全</category>
      </categories>
      <tags>
        <tag>Java安全</tag>
      </tags>
  </entry>
</search>
